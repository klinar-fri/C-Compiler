#ifndef PARSER_H
#define PARSER_H


typedef enum{
    RETURN_STMT,
    BIN_EXPR,
    LITERAL
} ASTNodeType;


typedef struct ASTNode{
    ASTNodeType type;
    union{
        struct{
            struct ASTNode* expression;
        } return_stmt;

        struct{
            char* operator;
            struct ASTNode* left;
            struct ASTNode* right;
        } bin_expr;

        struct{
            int value;
        } literal;
    };
    
} ASTNode;


ASTNode* parseExpr();
ASTNode* parseStmt();
ASTNode* parseTerm();

Tokens tokens;


int curr = 0;

Token* peek(){
    return &tokens.items[curr];
}

Token* advance(){
    if(tokens.size <= curr + 1){
        return NULL;
    }
    return &tokens.items[curr++];
}

bool match(TokenType type){
    if(peek()->tokenType == type){
        advance();
        return true;
    }
    return false;
}

ASTNode* parseStmt(){
    if(match(tok_reserved)){
        ASTNode* expr = parseExpr();
        match(tok_separator);
        ASTNode* node = malloc(sizeof(ASTNode));
        node->type = RETURN_STMT;
        node->return_stmt.expression = expr;
        return node;
    }
    return NULL;
}

ASTNode* parseExpr(){
    ASTNode* left = parseTerm();
    while(peek()->tokenType == tok_operator){
        char* op = advance()->tokenValue;
        if(op == NULL){
            printf("ERROR: End of the dynamic array!\n");
            break;
        }
        ASTNode* right = parseTerm();
        ASTNode* node = malloc(sizeof(ASTNode));
        node->type = BIN_EXPR;
        node->bin_expr.operator = op;
        node->bin_expr.left = left;
        node->bin_expr.right = right;
        left = node;
    }
    return left;
}

ASTNode* parseTerm(){
    if(match(tok_num)){
        ASTNode* node = malloc(sizeof(ASTNode));
        node->type = LITERAL;
        node->literal.value = atoi(tokens.items[curr - 1].tokenValue);
        return node;
    }else if(match(tok_separator) && (strcmp(tokens.items[curr - 1].tokenValue, "(") == 0)){
        ASTNode* expr = parseExpr();
        match(tok_separator);
        return expr;
    }
    return NULL; // ERROR
}

void print_indent(int indent) {
    for (int i = 0; i < indent; ++i) {
        printf("  "); // two spaces per indent level
    }
}

// print function generated by chat-gpt
void print_ast(ASTNode* node, int indent) {
    if (!node) {
        print_indent(indent);
        printf("NULL\n");
        return;
    }

    switch (node->type) {
        case RETURN_STMT:
            print_indent(indent);
            printf("ReturnStmt\n");
            print_ast(node->return_stmt.expression, indent + 1);
            break;

        case BIN_EXPR:
            print_indent(indent);
            printf("BinaryExpr: '%s'\n", node->bin_expr.operator);
            print_indent(indent + 1);
            printf("Left:\n");
            print_ast(node->bin_expr.left, indent + 2);
            print_indent(indent + 1);
            printf("Right:\n");
            print_ast(node->bin_expr.right, indent + 2);
            break;

        case LITERAL:
            print_indent(indent);
            printf("Literal: %d\n", node->literal.value);
            break;

        default:
            print_indent(indent);
            printf("Unknown AST Node\n");
            break;
    }
}


void parseTokens(Tokens* tokPtr){
    tokens = *tokPtr;
    ASTNode* root = parseStmt();
    print_ast(root, 0);
}

#endif